// Question 1
// Pring Adjencylist

 // User function Template for Java
import java.util.*;

class Solution {
    public List<List<Integer>> printGraph(int V, int edges[][]) {
        
        List<List<Integer>> ans = new ArrayList<>();
        
        // initialize adjacency list
        for (int i = 0; i < V; i++) {
            ans.add(new ArrayList<>());
        }

        // fill adjacency list
        for (int i = 0; i < edges.length; i++) {
            int u = edges[i][0];
            int v = edges[i][1];

            ans.get(u).add(v);
            ans.get(v).add(u); // because graph is undirected
        }

        return ans;
    }
}


// Question 2
// bfs Traversal of the graph

 import java.util.*;

class Solution {
    public ArrayList<Integer> bfs(ArrayList<ArrayList<Integer>> adj) {
        ArrayList<Integer> ans = new ArrayList<>();
        Queue<Integer> q = new LinkedList<>();
        boolean[] visited = new boolean[adj.size()];

        // start from node 0
        q.add(0);
        visited[0] = true;

        while (!q.isEmpty()) {
            int curr = q.remove();
            ans.add(curr);

            // visit all neighbors of curr
            for (int neighbor : adj.get(curr)) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    q.add(neighbor);
                }
            }
        }

        return ans;
    }
}


// Question 3
// dfs traversal 


import java.util.*;

class Solution {
    
    // DFS helper function
    public void dfs(ArrayList<ArrayList<Integer>> adj, int curr, boolean vis[], ArrayList<Integer> ans) {
        vis[curr] = true;
        ans.add(curr);

        for (int neighbor : adj.get(curr)) {
            if (!vis[neighbor]) {
                dfs(adj, neighbor, vis, ans);
            }
        }
    }

    // Main DFS function
    public ArrayList<Integer> dfsOfGraph(ArrayList<ArrayList<Integer>> adj) {
        ArrayList<Integer> ans = new ArrayList<>();
        boolean[] vis = new boolean[adj.size()];

        // start dfs from node 0
        dfs(adj, 0, vis, ans);

        return ans;
    }
}


// Question 4
// number of component of the matrix

class Solution {
    public void helper(int curr , List<List<Integer>> adj , boolean[] vis){
        vis[curr] = true;

        for(int i : adj.get(curr)){
            if(!vis[i]){
                helper(i,adj,vis);
            }
        }      
    }
    public int countComponents(int n, int[][] edges) {
        boolean vis[] = new boolean[n];
        int count = 0;

        List<List<Integer>> adj = new ArrayList<>();

        for(int i = 0 ; i<n; i++){
            adj.add(new ArrayList<>());
        }

        for(int[] edge : edges){
            adj.get(edge[0]).add(edge[1]);
            adj.get(edge[1]).add(edge[0]);
        }

        for(int i = 0; i<n; i++){
            if(!vis[i]){
                count++;
                helper(i,adj,vis);
            }
            
        }
        return count;
    }
}


// Question 5
// Cycle Detection in directed Graph

class Solution {
    public boolean helper(List<List<Integer>> adj , int curr, boolean vis[], boolean rec[]){
        
        vis[curr] = true;
        rec[curr] = true;
        
        for(int i : adj.get(curr)){
            if(rec[i])return true;
            if(!vis[i] && helper(adj,i,vis,rec)){
                return true;
            }
        }
        rec[curr] = false;
        
        return false;
    }
    public boolean isCyclic(int V, int[][] edges) {
        // code here
        List<List<Integer>> adj = new ArrayList<>();
        
        boolean vis[] = new boolean[V];
        boolean rec[] = new boolean[V];
        
        for(int i = 0; i<V; i++){
            adj.add(new ArrayList<>());
        }
        
        for(int i =0; i<edges.length; i++){
            int[] ed = edges[i];
            int src = ed[0];
            int des = ed[1];
            
            adj.get(src).add(des);
        }
        
        for(int i = 0; i<V; i++){
            if(!vis[i]){
                if(helper(adj,i,vis,rec)){
                    return true;
                }
            }
        }
        
        return false;
        
        
    }
}
